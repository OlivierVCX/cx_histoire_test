{"version":3,"file":"adblocker.umd.min.js","sources":["esm/index.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parse } from 'tldts-experimental';\nimport { FiltersEngine, Request } from '@ghostery/adblocker';\nimport { autoRemoveScript, extractFeaturesFromDOM, DOMMonitor } from '@ghostery/adblocker-content';\nfunction sleep(milliseconds) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, milliseconds);\n    });\n}\nfunction getTopLevelUrl(frame) {\n    let sourceUrl = '';\n    while (frame !== null) {\n        sourceUrl = frame.url();\n        if (sourceUrl.length !== 0) {\n            break;\n        }\n        frame = frame.parentFrame();\n    }\n    return sourceUrl;\n}\n/**\n * Create an instance of `Request` from `puppeteer.Request`.\n */\nexport function fromPuppeteerDetails(details) {\n    const sourceUrl = getTopLevelUrl(details.frame());\n    const url = details.url();\n    const type = details.resourceType();\n    return Request.fromRawDetails({\n        _originalRequestDetails: details,\n        requestId: `${type}-${url}-${sourceUrl}`,\n        sourceUrl,\n        type,\n        url,\n    });\n}\n/**\n * Wrap `FiltersEngine` into a Puppeteer-friendly helper class.\n */\nexport class BlockingContext {\n    constructor(page, blocker) {\n        this.page = page;\n        this.blocker = blocker;\n        this.onFrameNavigated = (frame) => blocker.onFrameNavigated(frame);\n        this.onDomContentLoaded = () => blocker.onFrameNavigated(this.page.mainFrame());\n        this.onRequest = (request) => blocker.onRequest(request);\n    }\n    async enable() {\n        if (this.blocker.config.loadCosmeticFilters) {\n            // Register callbacks to cosmetics injection (CSS + scriptlets)\n            this.page.on('frameattached', this.onFrameNavigated);\n            this.page.on('domcontentloaded', this.onDomContentLoaded);\n        }\n        if (this.blocker.config.loadNetworkFilters) {\n            // Make sure request interception is enabled for `page` before proceeding\n            await this.page.setRequestInterception(true);\n            // NOTES:\n            //  - page.setBypassCSP(enabled) might be needed to perform\n            //  injections on some pages.\n            //  - we currently do not perform CSP headers injection as there is\n            //  currently no way to modify responses in puppeteer. This feature could\n            //  easily be added if puppeteer implements the required capability.\n            //\n            // Register callback for network requests filtering.\n            this.page.on('request', this.onRequest);\n        }\n    }\n    async disable({ keepRequestInterception = false, } = {}) {\n        if (this.blocker.config.loadNetworkFilters) {\n            this.page.off('request', this.onRequest);\n            if (keepRequestInterception === false) {\n                await this.page.setRequestInterception(false);\n            }\n        }\n        if (this.blocker.config.loadCosmeticFilters) {\n            this.page.off('frameattached', this.onFrameNavigated);\n            this.page.off('domcontentloaded', this.onDomContentLoaded);\n        }\n    }\n}\n/**\n * Wrap `FiltersEngine` into a Puppeteer-friendly helper class. It exposes\n * methods to interface with Puppeteer APIs needed to block ads.\n */\nexport class PuppeteerBlocker extends FiltersEngine {\n    constructor() {\n        super(...arguments);\n        this.contexts = new WeakMap();\n        // Defaults to undefined which preserves Legacy Mode behavior\n        this.priority = undefined;\n        // ----------------------------------------------------------------------- //\n        // PuppeteerBlocker-specific additions to FiltersEngine\n        // ----------------------------------------------------------------------- //\n        this.onFrameNavigated = async (frame) => {\n            try {\n                await this.onFrame(frame);\n            }\n            catch (ex) {\n                // Ignore\n            }\n        };\n        this.onFrame = async (frame) => {\n            const url = frame.url();\n            if (url === 'chrome-error://chromewebdata/') {\n                return;\n            }\n            // Look for all iframes in this context and check if they should be removed\n            // from the DOM completely. For this we check if their `src` or `href`\n            // attribute would be blocked by any network filter.\n            this.removeBlockedFrames(frame).catch(() => {\n                /* ignore */\n            });\n            const parsed = parse(url);\n            const hostname = parsed.hostname || '';\n            const domain = parsed.domain || '';\n            // We first query for stylesheets and scriptlets which are either generic or\n            // based on the hostname of this frame. We need to get these as fast as\n            // possible to reduce blinking when page loads.\n            {\n                // TODO - implement extended filters for Puppeteer\n                const { active, styles, scripts /* , extended */ } = this.getCosmeticsFilters({\n                    domain,\n                    hostname,\n                    url,\n                    // Done once per frame.\n                    getBaseRules: true,\n                    getInjectionRules: true,\n                    getExtendedRules: true,\n                    getRulesFromHostname: true,\n                    // Will handle DOM features (see below).\n                    getRulesFromDOM: false,\n                });\n                if (active === false) {\n                    return;\n                }\n                Promise.all([\n                    this.injectScriptletsIntoFrame(frame, scripts),\n                    this.injectStylesIntoFrame(frame, styles),\n                ]).catch(() => {\n                    /* ignore */\n                });\n            }\n            // Seconde step is to start monitoring the DOM of the page in order to\n            // inject more specific selectors based on `id`, `class`, or `href` found on\n            // nodes. We first query all of them, then monitor the DOM for a few\n            // seconds (or until one of the stopping conditions is met, see below).\n            const observer = new DOMMonitor((update) => {\n                if (update.type === 'features') {\n                    const { active, styles } = this.getCosmeticsFilters({\n                        domain,\n                        hostname,\n                        url,\n                        // DOM information\n                        ...update,\n                        // Only done once per frame (see above).\n                        getBaseRules: false,\n                        getInjectionRules: false,\n                        getExtendedRules: false,\n                        getRulesFromHostname: false,\n                        // Allows to get styles for updated DOM.\n                        getRulesFromDOM: true,\n                    });\n                    // Abort if cosmetics are disabled\n                    if (active === false) {\n                        return;\n                    }\n                    this.injectStylesIntoFrame(frame, styles).catch(() => {\n                        /* ignore */\n                    });\n                }\n            });\n            // This loop will periodically check if any new custom styles should be\n            // injected in the page (using values of attributes `id`, `class`, or `href`).\n            //\n            // We stop looking in the following cases:\n            // * Frame was detached.\n            // * No new attribute was found.\n            // * Number of iterations exceeded 10 (i.e. 5 seconds).\n            // * Exception was raised.\n            //\n            // Additionally, we might stop after the first lookup if\n            // `enableMutationObserver` is disabled in config, which means that we\n            // should not actively monitor the DOM for changes.\n            let numberOfIterations = 0;\n            do {\n                if (frame.detached) {\n                    break;\n                }\n                try {\n                    const foundNewFeatures = observer.handleNewFeatures(await frame.$$eval(':root', extractFeaturesFromDOM));\n                    numberOfIterations += 1;\n                    if (numberOfIterations === 10) {\n                        break;\n                    }\n                    if (foundNewFeatures === false) {\n                        break;\n                    }\n                }\n                catch (ex) {\n                    break;\n                }\n                if (this.config.enableMutationObserver === false) {\n                    break;\n                }\n                await sleep(500);\n                // eslint-disable-next-line no-constant-condition\n            } while (true);\n        };\n        this.setRequestInterceptionPriority = (defaultPriority = 0) => (this.priority = defaultPriority);\n        this.onRequest = (details) => {\n            var _a, _b, _c;\n            if ((_a = details.isInterceptResolutionHandled) === null || _a === void 0 ? void 0 : _a.call(details)) {\n                return;\n            }\n            const request = fromPuppeteerDetails(details);\n            if (this.config.guessRequestTypeFromUrl === true && request.type === 'other') {\n                request.guessTypeOfRequest();\n            }\n            const frame = details.frame();\n            if (request.isMainFrame() ||\n                (request.type === 'document' && frame !== null && frame.parentFrame() === null)) {\n                details.continue((_b = details.continueRequestOverrides) === null || _b === void 0 ? void 0 : _b.call(details), 0);\n                return;\n            }\n            const { redirect, match } = this.match(request);\n            if (redirect !== undefined) {\n                if (redirect.contentType.endsWith(';base64')) {\n                    details.respond({\n                        status: 200,\n                        headers: {},\n                        body: Buffer.from(redirect.body, 'base64'),\n                        contentType: redirect.contentType.slice(0, -7),\n                    }, this.priority);\n                }\n                else {\n                    details.respond({\n                        status: 200,\n                        headers: {},\n                        body: redirect.body,\n                        contentType: redirect.contentType,\n                    }, this.priority);\n                }\n            }\n            else if (match === true) {\n                details.abort('blockedbyclient', this.priority);\n            }\n            else {\n                details.continue((_c = details.continueRequestOverrides) === null || _c === void 0 ? void 0 : _c.call(details), 0);\n            }\n        };\n    }\n    // ----------------------------------------------------------------------- //\n    // Helpers to enable and disable blocking for 'browser'\n    // ----------------------------------------------------------------------- //\n    async enableBlockingInPage(page) {\n        let context = this.contexts.get(page);\n        if (context !== undefined) {\n            return context;\n        }\n        context = new BlockingContext(page, this);\n        this.contexts.set(page, context);\n        await context.enable();\n        return context;\n    }\n    async disableBlockingInPage(page, { keepRequestInterception = false } = {}) {\n        const context = this.contexts.get(page);\n        if (context === undefined) {\n            throw new Error('Trying to disable blocking which was not enabled');\n        }\n        this.contexts.delete(page);\n        await context.disable({ keepRequestInterception });\n    }\n    isBlockingEnabled(page) {\n        return this.contexts.has(page);\n    }\n    async injectStylesIntoFrame(frame, styles) {\n        if (styles.length !== 0) {\n            await frame.addStyleTag({\n                content: styles,\n            });\n        }\n    }\n    async injectScriptletsIntoFrame(frame, scripts) {\n        const promises = [];\n        if (scripts.length !== 0) {\n            for (let i = 0; i < scripts.length; i += 1) {\n                promises.push(frame\n                    .addScriptTag({\n                    content: autoRemoveScript(scripts[i]),\n                })\n                    .then(() => {\n                    /* Ignore result */\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n    /**\n     * Look for sub-frames in `frame`, check if their `src` or `href` would be\n     * blocked, and then proceed to removing them from the DOM completely.\n     */\n    async removeBlockedFrames(frame) {\n        const promises = [];\n        const sourceUrl = getTopLevelUrl(frame);\n        for (const url of await frame.$$eval('iframe[src],iframe[href]', (elements) => elements.map(({ src, href }) => src || href))) {\n            const { match } = this.match(Request.fromRawDetails({\n                url,\n                sourceUrl,\n                type: 'sub_frame',\n            }));\n            if (match) {\n                promises.push(frame\n                    .$$eval(`iframe[src=\"${url}\"],iframe[href=\"${url}\"]`, (iframes) => {\n                    var _a;\n                    for (const iframe of iframes) {\n                        (_a = iframe === null || iframe === void 0 ? void 0 : iframe.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(iframe);\n                    }\n                })\n                    .catch(() => {\n                    /* ignore */\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n}\n// Re-export symboles from @ghostery/adblocker for convenience\nexport * from '@ghostery/adblocker';\n//# sourceMappingURL=index.js.map"],"names":["sleep","milliseconds","Promise","resolve","setTimeout","getTopLevelUrl","frame","sourceUrl","url","length","parentFrame","fromPuppeteerDetails","details","type","resourceType","Request","fromRawDetails","_originalRequestDetails","requestId","BlockingContext","constructor","page","blocker","this","onFrameNavigated","onDomContentLoaded","mainFrame","onRequest","request","enable","config","loadCosmeticFilters","on","loadNetworkFilters","setRequestInterception","disable","keepRequestInterception","off","PuppeteerBlocker","FiltersEngine","super","arguments","contexts","WeakMap","priority","undefined","async","onFrame","ex","removeBlockedFrames","catch","parsed","parse","hostname","domain","active","styles","scripts","getCosmeticsFilters","getBaseRules","getInjectionRules","getExtendedRules","getRulesFromHostname","getRulesFromDOM","all","injectScriptletsIntoFrame","injectStylesIntoFrame","observer","DOMMonitor","update","numberOfIterations","detached","foundNewFeatures","handleNewFeatures","$$eval","extractFeaturesFromDOM","enableMutationObserver","setRequestInterceptionPriority","defaultPriority","_a","_b","_c","isInterceptResolutionHandled","call","guessRequestTypeFromUrl","guessTypeOfRequest","isMainFrame","continue","continueRequestOverrides","redirect","match","contentType","endsWith","respond","status","headers","body","Buffer","from","slice","abort","enableBlockingInPage","context","get","set","disableBlockingInPage","Error","delete","isBlockingEnabled","has","addStyleTag","content","promises","i","push","addScriptTag","autoRemoveScript","then","elements","map","src","href","iframes","iframe","parentNode","removeChild"],"mappings":"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"}