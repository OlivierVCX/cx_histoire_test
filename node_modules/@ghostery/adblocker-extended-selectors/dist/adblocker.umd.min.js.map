{"version":3,"file":"adblocker.umd.min.js","sources":["esm/types.js","esm/parse.js","esm/eval.js","esm/extended.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst tokenTypes = [\n    'attribute',\n    'id',\n    'class',\n    'comma',\n    'combinator',\n    'pseudo-element',\n    'pseudo-class',\n    'type',\n];\nexport function isAtoms(tokens) {\n    return tokens.every((token) => typeof token !== 'string');\n}\nexport function isAST(tokens) {\n    return tokens.every((token) => token.type !== 'comma' && token.type !== 'combinator');\n}\n//# sourceMappingURL=types.js.map","/*!\n * Based on parsel. Extended by Rémi Berson for Ghostery (2021).\n * https://github.com/LeaVerou/parsel\n *\n * MIT License\n *\n * Copyright (c) 2020 Lea Verou\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { isAST, isAtoms } from './types.js';\nexport const RECURSIVE_PSEUDO_CLASSES = new Set([\n    'any',\n    'dir',\n    'has',\n    'host-context',\n    'is',\n    'matches',\n    'not',\n    'where',\n]);\nconst TOKENS = {\n    attribute: /\\[\\s*(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(?<caseSensitive>[iIsS])?\\s*)?\\]/gu,\n    id: /#(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    class: /\\.(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    comma: /\\s*,\\s*/g, // must be before combinator\n    combinator: /\\s*[\\s>+~]\\s*/g, // this must be after attribute\n    'pseudo-element': /::(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?:¶*)\\))?/gu, // this must be before pseudo-class\n    'pseudo-class': /:(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>¶*)\\))?/gu,\n    type: /(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)|\\*/gu, // this must be last\n};\nconst TOKENS_WITH_PARENS = new Set(['pseudo-class', 'pseudo-element']);\nconst TOKENS_WITH_STRINGS = new Set([...TOKENS_WITH_PARENS, 'attribute']);\nconst TRIM_TOKENS = new Set(['combinator', 'comma']);\nconst TOKENS_FOR_RESTORE = Object.assign({}, TOKENS);\nTOKENS_FOR_RESTORE['pseudo-element'] = RegExp(TOKENS['pseudo-element'].source.replace('(?<argument>¶*)', '(?<argument>.*?)'), 'gu');\nTOKENS_FOR_RESTORE['pseudo-class'] = RegExp(TOKENS['pseudo-class'].source.replace('(?<argument>¶*)', '(?<argument>.*)'), 'gu');\n// TODO - it feels like with some more typing shenanigans we could replace groups validation by generic logic in this function.\nfunction splitOnMatch(pattern, str) {\n    pattern.lastIndex = 0;\n    const match = pattern.exec(str);\n    if (match === null) {\n        return undefined;\n    }\n    const from = match.index - 1;\n    const content = match[0];\n    const before = str.slice(0, from + 1);\n    const after = str.slice(from + content.length + 1);\n    return [before, [content, match.groups || {}], after];\n}\nconst GRAMMAR = [\n    // attribute\n    (str) => {\n        const match = splitOnMatch(TOKENS.attribute, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, operator, value, namespace, caseSensitive }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'attribute',\n                content,\n                length: content.length,\n                namespace,\n                caseSensitive,\n                pos: [],\n                name,\n                operator,\n                value,\n            },\n            after,\n        ];\n    },\n    // #id\n    (str) => {\n        const match = splitOnMatch(TOKENS.id, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'id',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // .class\n    (str) => {\n        const match = splitOnMatch(TOKENS.class, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // comma ,\n    (str) => {\n        const match = splitOnMatch(TOKENS.comma, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'comma',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // combinator\n    (str) => {\n        const match = splitOnMatch(TOKENS.combinator, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'combinator',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // pseudo-element\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-element'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-element',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // pseudo-class\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-class'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        // TODO - here `argument` can be undefined and should be rejected?\n        const [before, [content, { name, argument }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n                argument,\n                subtree: undefined,\n            },\n            after,\n        ];\n    },\n    // type\n    (str) => {\n        const match = splitOnMatch(TOKENS.type, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, namespace }], after] = match;\n        return [\n            before,\n            {\n                type: 'type',\n                content,\n                length: content.length,\n                namespace,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n];\nfunction tokenizeBy(text) {\n    if (!text) {\n        return [];\n    }\n    const strarr = [text];\n    for (const tokenizer of GRAMMAR) {\n        for (let i = 0; i < strarr.length; i++) {\n            const str = strarr[i];\n            if (typeof str === 'string') {\n                const match = tokenizer(str);\n                if (match !== undefined) {\n                    strarr.splice(i, 1, ...match.filter((a) => a.length !== 0));\n                }\n            }\n        }\n    }\n    let offset = 0;\n    for (const token of strarr) {\n        if (typeof token !== 'string') {\n            token.pos = [offset, offset + token.length];\n            if (TRIM_TOKENS.has(token.type)) {\n                token.content = token.content.trim() || ' ';\n            }\n        }\n        offset += token.length;\n    }\n    if (isAtoms(strarr)) {\n        return strarr;\n    }\n    // NOTE: here this means that parsing failed.\n    return [];\n}\nfunction restoreNested(tokens, strings, regex, types) {\n    // TODO - here from offsets in strings and tokens we should be able to find the exact spot without RegExp?\n    for (const str of strings) {\n        for (const token of tokens) {\n            if (types.has(token.type) && token.pos[0] < str.start && str.start < token.pos[1]) {\n                const content = token.content;\n                token.content = token.content.replace(regex, str.str);\n                if (token.content !== content) {\n                    // actually changed?\n                    // Re-evaluate groups\n                    TOKENS_FOR_RESTORE[token.type].lastIndex = 0;\n                    const match = TOKENS_FOR_RESTORE[token.type].exec(token.content);\n                    if (match !== null) {\n                        Object.assign(token, match.groups);\n                    }\n                }\n            }\n        }\n    }\n}\nexport function isEscaped(str, index) {\n    let backslashes = 0;\n    index -= 1;\n    while (index >= 0 && str[index] === '\\\\') {\n        backslashes += 1;\n        index -= 1;\n    }\n    return backslashes % 2 !== 0;\n}\nexport function gobbleQuotes(text, quote, start) {\n    // Find end of quote, taking care of ignoring escaped quotes\n    let end = start + 1;\n    while ((end = text.indexOf(quote, end)) !== -1 && isEscaped(text, end) === true) {\n        end += 1;\n    }\n    if (end === -1) {\n        // Opening quote without closing quote\n        return undefined;\n    }\n    return text.slice(start, end + 1);\n}\nexport function gobbleParens(text, start) {\n    let stack = 0;\n    for (let i = start; i < text.length; i++) {\n        const char = text[i];\n        if (char === '(') {\n            stack += 1;\n        }\n        else if (char === ')') {\n            if (stack > 0) {\n                stack -= 1;\n            }\n            else {\n                // Closing paren without opening paren\n                return undefined;\n            }\n        }\n        if (stack === 0) {\n            return text.slice(start, i + 1);\n        }\n    }\n    // Opening paren without closing paren\n    return undefined;\n}\nexport function replace(selector, replacement, opening, gobble) {\n    const strings = [];\n    let offset = 0;\n    while ((offset = selector.indexOf(opening, offset)) !== -1) {\n        const str = gobble(selector, offset);\n        if (str === undefined) {\n            break;\n        }\n        strings.push({ str, start: offset });\n        selector = `${selector.slice(0, offset + 1)}${replacement.repeat(str.length - 2)}${selector.slice(offset + str.length - 1)}`;\n        offset += str.length;\n    }\n    return [strings, selector];\n}\nexport function tokenize(selector) {\n    if (typeof selector !== 'string') {\n        return [];\n    }\n    // Prevent leading/trailing whitespace be interpreted as combinators\n    selector = selector.trim();\n    if (selector.length === 0) {\n        return [];\n    }\n    // Replace strings with whitespace strings (to preserve offsets)\n    const [doubleQuotes, selectorWithoutDoubleQuotes] = replace(selector, '§', '\"', (text, start) => gobbleQuotes(text, '\"', start));\n    const [singleQuotes, selectorWithoutQuotes] = replace(selectorWithoutDoubleQuotes, '§', \"'\", (text, start) => gobbleQuotes(text, \"'\", start));\n    // Now that strings are out of the way, extract parens and replace them with parens with whitespace (to preserve offsets)\n    const [parens, selectorWithoutParens] = replace(selectorWithoutQuotes, '¶', '(', gobbleParens);\n    // Now we have no nested structures and we can parse with regexes\n    const tokens = tokenizeBy(selectorWithoutParens);\n    // Now restore parens and strings in reverse order\n    restoreNested(tokens, parens, /\\(¶*\\)/, TOKENS_WITH_PARENS);\n    restoreNested(tokens, doubleQuotes, /\"§*\"/, TOKENS_WITH_STRINGS);\n    restoreNested(tokens, singleQuotes, /'§*'/, TOKENS_WITH_STRINGS);\n    return tokens;\n}\n// Convert a flat list of tokens into a tree of complex & compound selectors\nfunction nestTokens(tokens, { list = true } = {}) {\n    if (list === true && tokens.some((t) => t.type === 'comma')) {\n        const selectors = [];\n        const temp = [];\n        for (let i = 0; i < tokens.length; i += 1) {\n            const token = tokens[i];\n            if (token.type === 'comma') {\n                if (temp.length === 0) {\n                    throw new Error('Incorrect comma at ' + i);\n                }\n                const sub = nestTokens(temp, { list: false });\n                if (sub !== undefined) {\n                    selectors.push(sub);\n                }\n                temp.length = 0;\n            }\n            else {\n                temp.push(token);\n            }\n        }\n        if (temp.length === 0) {\n            throw new Error('Trailing comma');\n        }\n        else {\n            const sub = nestTokens(temp, { list: false });\n            if (sub !== undefined) {\n                selectors.push(sub);\n            }\n        }\n        return { type: 'list', list: selectors };\n    }\n    for (let i = tokens.length - 1; i >= 0; i--) {\n        const token = tokens[i];\n        if (token.type === 'combinator') {\n            const left = nestTokens(tokens.slice(0, i));\n            const right = nestTokens(tokens.slice(i + 1));\n            if (right === undefined) {\n                return undefined;\n            }\n            if (token.content !== ' ' &&\n                token.content !== '~' &&\n                token.content !== '+' &&\n                token.content !== '>') {\n                return undefined;\n            }\n            return {\n                type: 'complex',\n                combinator: token.content,\n                left,\n                right,\n            };\n        }\n    }\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    if (isAST(tokens)) {\n        if (tokens.length === 1) {\n            return tokens[0];\n        }\n        // If we're here, there are no combinators, so it's just a list\n        return {\n            type: 'compound',\n            compound: [...tokens], // clone to avoid pointers messing up the AST\n        };\n    }\n    return undefined;\n}\n// Traverse an AST (or part thereof), in depth-first order\nfunction walk(node, callback, o, parent) {\n    if (node === undefined) {\n        return;\n    }\n    if (node.type === 'complex') {\n        walk(node.left, callback, o, node);\n        walk(node.right, callback, o, node);\n    }\n    else if (node.type === 'compound') {\n        for (const n of node.compound) {\n            walk(n, callback, o, node);\n        }\n    }\n    else if (node.type === 'pseudo-class' &&\n        node.subtree !== undefined &&\n        o !== undefined &&\n        o.type === 'pseudo-class' &&\n        o.subtree !== undefined) {\n        walk(node.subtree, callback, o, node);\n    }\n    callback(node, parent);\n}\n/**\n * Parse a CSS selector\n * @param selector {String} The selector to parse\n * @param options.recursive {Boolean} Whether to parse the arguments of pseudo-classes like :is(), :has() etc. Defaults to true.\n * @param options.list {Boolean} Whether this can be a selector list (A, B, C etc). Defaults to true.\n */\nexport function parse(selector, { recursive = true, list = true } = {}) {\n    const tokens = tokenize(selector);\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    const ast = nestTokens(tokens, { list });\n    if (recursive === true) {\n        walk(ast, (node) => {\n            if (node.type === 'pseudo-class' &&\n                node.argument &&\n                node.name !== undefined &&\n                RECURSIVE_PSEUDO_CLASSES.has(node.name)) {\n                node.subtree = parse(node.argument, { recursive: true, list: true });\n            }\n        });\n    }\n    return ast;\n}\n//# sourceMappingURL=parse.js.map","/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Evaluates an XPath expression and returns matching Element nodes.\n * @param element - The context element for XPath evaluation\n * @param xpathExpression - The XPath expression to evaluate\n * @returns Array of Element nodes that match the XPath expression\n */\nfunction handleXPathSelector(element, xpathExpression) {\n    try {\n        if (typeof Node === 'undefined' || typeof XPathResult === 'undefined') {\n            return []; // unsupported (not running in the browser)\n        }\n        const result = element.ownerDocument.evaluate(xpathExpression, element, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);\n        if (result.resultType !== XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {\n            return [];\n        }\n        const elements = [];\n        for (let i = 0; i < result.snapshotLength; i++) {\n            const node = result.snapshotItem(i);\n            if ((node === null || node === void 0 ? void 0 : node.nodeType) === Node.ELEMENT_NODE) {\n                elements.push(node);\n            }\n        }\n        return elements;\n    }\n    catch (e) {\n        return [];\n    }\n}\nfunction parseCSSValue(cssValue) {\n    const firstColonIndex = cssValue.indexOf(':');\n    if (firstColonIndex === -1) {\n        throw new Error('Invalid CSS value format: no colon found');\n    }\n    const property = cssValue.slice(0, firstColonIndex).trim();\n    const value = cssValue.slice(firstColonIndex + 1).trim();\n    const isRegex = value.startsWith('/') && value.lastIndexOf('/') > 0;\n    return { property, value, isRegex };\n}\nfunction matchCSSProperty(element, cssValue, pseudoElement) {\n    const { property, value, isRegex } = parseCSSValue(cssValue);\n    const win = element.ownerDocument && element.ownerDocument.defaultView;\n    if (!win)\n        throw new Error('No window context for element');\n    const computedStyle = win.getComputedStyle(element, pseudoElement);\n    const actualValue = computedStyle[property];\n    if (isRegex) {\n        const regex = parseRegex(value);\n        return regex.test(actualValue);\n    }\n    return actualValue === value;\n}\nfunction parseRegex(str) {\n    if (str.startsWith('/') && str.lastIndexOf('/') > 0) {\n        const lastSlashIndex = str.lastIndexOf('/');\n        const pattern = str.slice(1, lastSlashIndex);\n        const flags = str.slice(lastSlashIndex + 1);\n        if (!/^[gimsuyd]*$/.test(flags)) {\n            throw new Error(`Invalid regex flags: ${flags}`);\n        }\n        return new RegExp(pattern, flags);\n    }\n    else {\n        return new RegExp(str);\n    }\n}\nfunction stripsWrappingQuotes(str) {\n    if ((str.startsWith('\"') && str.endsWith('\"')) || (str.startsWith(\"'\") && str.endsWith(\"'\"))) {\n        return str.slice(1, -1);\n    }\n    return str;\n}\nexport function matchPattern(pattern, text) {\n    pattern = stripsWrappingQuotes(pattern);\n    // TODO - support 'm' RegExp argument\n    if (pattern.startsWith('/') && (pattern.endsWith('/') || pattern.endsWith('/i'))) {\n        let caseSensitive = true;\n        pattern = pattern.slice(1);\n        if (pattern.endsWith('/')) {\n            pattern = pattern.slice(0, -1);\n        }\n        else {\n            pattern = pattern.slice(0, -2);\n            caseSensitive = false;\n        }\n        return new RegExp(pattern, caseSensitive === false ? 'i' : undefined).test(text);\n    }\n    return text.includes(pattern);\n}\n/**\n * Checks if the given element complies with the given selector.\n * @param element The subjective element.\n * @param selector The selector.\n */\nexport function matches(element, selector) {\n    var _a;\n    if (selector.type === 'id' ||\n        selector.type === 'class' ||\n        selector.type === 'type' ||\n        selector.type === 'attribute') {\n        return element.matches(selector.content);\n    }\n    else if (selector.type === 'list') {\n        return selector.list.some((s) => matches(element, s));\n    }\n    else if (selector.type === 'compound') {\n        // Compound selectors contain only simple selectors (id, class, type, attribute, pseudo-class)\n        // that must all match the same element. Complex selectors (with combinators like >, +, ~)\n        // are processed at a higher level by the parser, so they can never be children of compound selectors.\n        return selector.compound.every((s) => matches(element, s));\n    }\n    else if (selector.type === 'pseudo-class') {\n        if (selector.name === 'has') {\n            // The subjective element of `:has` check may be the given element or its children:\n            // - e.g. `html:has(body)`, `body` is the expected subjective to be filtered by `traverse`.\n            // - e.g. `html:has(>body)`, `html` is the subjective element to be filtered by `branch` then `traverse`.\n            // `querySelectorAll` already describes the all.\n            return (selector.subtree !== undefined && querySelectorAll(element, selector.subtree).length !== 0);\n        }\n        else if (selector.name === 'not') {\n            // Unlike `:has`, `:not` assumes the subtree to be the condition for the given element.\n            return selector.subtree !== undefined && traverse(element, [selector.subtree]).length === 0;\n        }\n        else if (selector.name === 'has-text') {\n            const { argument } = selector;\n            if (argument === undefined) {\n                return false;\n            }\n            const text = element.textContent;\n            if (text === null) {\n                return false;\n            }\n            return matchPattern(argument, text.trim());\n        }\n        else if (selector.name === 'min-text-length') {\n            const minLength = Number(selector.argument);\n            if (Number.isNaN(minLength) || minLength < 0) {\n                return false;\n            }\n            const text = element.textContent;\n            if (text === null) {\n                return false;\n            }\n            return text.length >= minLength;\n        }\n        else if (selector.name === 'matches-path') {\n            const { argument } = selector;\n            if (argument === undefined) {\n                return false;\n            }\n            const window = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n            if (!window) {\n                return false;\n            }\n            // Get both pathname and search (query parameters)\n            const path = window.location.pathname;\n            const search = window.location.search;\n            const fullUrl = path + search;\n            const regex = parseRegex(argument);\n            return regex.test(fullUrl);\n        }\n        else if (selector.name === 'matches-attr') {\n            const { argument } = selector;\n            if (argument === undefined) {\n                return false;\n            }\n            const indexOfEqual = argument.indexOf('=');\n            let namePattern;\n            let valuePattern;\n            if (indexOfEqual === -1) {\n                namePattern = argument;\n            }\n            else {\n                namePattern = argument.slice(0, indexOfEqual);\n                valuePattern = argument.slice(indexOfEqual + 1);\n            }\n            namePattern = stripsWrappingQuotes(namePattern);\n            valuePattern = valuePattern ? stripsWrappingQuotes(valuePattern) : undefined;\n            let valueRegex = null;\n            if ((valuePattern === null || valuePattern === void 0 ? void 0 : valuePattern.startsWith('/')) && valuePattern.lastIndexOf('/') > 0) {\n                valueRegex = parseRegex(valuePattern);\n            }\n            if (namePattern.startsWith('/') && namePattern.lastIndexOf('/') > 0) {\n                // matching attribute name by regex\n                const regex = parseRegex(namePattern);\n                const matchingAttrs = [...element.attributes].filter((attr) => regex.test(attr.name));\n                // If no value pattern, return true if any attribute matches the name pattern\n                if (!valuePattern) {\n                    return matchingAttrs.length > 0;\n                }\n                // Check if any of the matching attributes have the specified value\n                return matchingAttrs.some((attr) => valueRegex ? valueRegex.test(attr.value) : attr.value === valuePattern);\n            }\n            else {\n                // matching attribute name by string\n                const value = element.getAttribute(namePattern);\n                // null means the attribute is not present\n                if (value === null) {\n                    return false;\n                }\n                // early exit if no value pattern is provided\n                if (!valuePattern) {\n                    return true;\n                }\n                return valueRegex ? valueRegex.test(value) : value === valuePattern;\n            }\n        }\n        else if (selector.name === 'matches-css') {\n            return selector.argument !== undefined && matchCSSProperty(element, selector.argument);\n        }\n        else if (selector.name === 'matches-css-after') {\n            return (selector.argument !== undefined && matchCSSProperty(element, selector.argument, '::after'));\n        }\n        else if (selector.name === 'matches-css-before') {\n            return (selector.argument !== undefined && matchCSSProperty(element, selector.argument, '::before'));\n        }\n    }\n    return false;\n}\n/**\n * Describes CSS combinator behaviors from the given element.\n * @param element The current subjective element.\n * @param selector A complex selector.\n */\nfunction handleComplexSelector(element, selector) {\n    // The *left* part of the given selector is not queried by the previous step.\n    // If there's no *left* part, we fallback to the current element.\n    const leftElements = selector.left === undefined ? [element] : querySelectorAll(element, selector.left);\n    // The *right* part of the given selector is always *singular*.\n    // The understanding of `compound` selector behavior differs by `match` and `querySelectorAll`.\n    // The `compound` handler in `querySelectorAll` assume the subjective to be queried.\n    // However, our *actual* subjective elements are coming from *left* part of the selector.\n    // Therefore, we unmarshal the `compound` selector and directly use `traversal` which will involve `compound` handling in `match`.\n    const selectors = selector.right.type === 'compound' ? selector.right.compound : [selector.right];\n    const results = new Set();\n    switch (selector.combinator) {\n        case ' ':\n            // Look for all children *in any depth* of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                for (const child of leftElement.querySelectorAll('*')) {\n                    for (const result of traverse(child, selectors)) {\n                        results.add(result);\n                    }\n                }\n            }\n            break;\n        case '>':\n            // Look for all children of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                for (const child of leftElement.children) {\n                    for (const result of traverse(child, selectors)) {\n                        results.add(result);\n                    }\n                }\n            }\n            break;\n        case '~':\n            // Look for all siblings of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                let sibling = leftElement;\n                while ((sibling = sibling.nextElementSibling) !== null) {\n                    for (const result of traverse(sibling, selectors)) {\n                        results.add(result);\n                    }\n                }\n            }\n            break;\n        case '+':\n            // Look for a next sibiling of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                if (leftElement.nextElementSibling === null) {\n                    continue;\n                }\n                for (const result of traverse(leftElement.nextElementSibling, selectors)) {\n                    results.add(result);\n                }\n            }\n            break;\n    }\n    return Array.from(results);\n}\n/**\n * Transposes the given element with a selector.\n * @param element The subjective element\n * @param selector A selector\n * @returns An array of elements or null if not a transpose operator.\n */\nfunction transpose(element, selector) {\n    if (selector.type === 'pseudo-class') {\n        if (selector.name === 'upward') {\n            if (selector.argument === undefined) {\n                return [];\n            }\n            const argument = stripsWrappingQuotes(selector.argument);\n            let parentElement = element;\n            let number = Number(argument);\n            if (Number.isInteger(number)) {\n                if (number <= 0 || number >= 256) {\n                    return [];\n                }\n                while ((parentElement = parentElement.parentElement) !== null) {\n                    if (--number === 0) {\n                        return [parentElement];\n                    }\n                }\n            }\n            else {\n                while ((parentElement = parentElement.parentElement) !== null) {\n                    if (parentElement.matches(argument)) {\n                        return [parentElement];\n                    }\n                }\n            }\n            return [];\n        }\n        else if (selector.name === 'xpath') {\n            if (selector.argument === undefined) {\n                return [];\n            }\n            return handleXPathSelector(element, selector.argument);\n        }\n    }\n    return null;\n}\n/**\n * Checks elements by traversing from the given element.\n * You need to decide the subjective element candidates manually.\n * It doesn't look for the children of the given element.\n * @param root The subjective element.\n * @param selectors The selector list to validate with.\n * @returns If the given element and all followed candidate fails, it returns an empty array.\n */\nfunction traverse(root, selectors) {\n    if (selectors.length === 0) {\n        return [];\n    }\n    const traversals = [{ element: root, index: 0 }];\n    const results = [];\n    while (traversals.length) {\n        const traversal = traversals.pop();\n        const { element } = traversal;\n        let { index } = traversal;\n        for (; index < selectors.length; index++) {\n            const candidates = transpose(element, selectors[index]);\n            const isTransposeOperator = candidates !== null;\n            if (isTransposeOperator) {\n                traversals.push(...candidates.map((element) => ({ element, index: index + 1 })));\n                break;\n            }\n            else if (matches(element, selectors[index]) === false) {\n                // no maches found - stop processing the branch\n                break;\n            }\n        }\n        // Check if the loop was completed\n        if (index === selectors.length && !results.includes(element)) {\n            results.push(element);\n        }\n    }\n    return results;\n}\nexport function querySelectorAll(element, selector) {\n    // Type of `attribute`, `class`, `id`, and `type` are to express simple selectors.\n    // e.g. `[attr]` is `attribute` type, `.cls` is `class` type, `#lure` is `id` type, and `div` is `type` type.\n    if (selector.type === 'id' ||\n        selector.type === 'class' ||\n        selector.type === 'type' ||\n        selector.type === 'attribute') {\n        return Array.from(element.querySelectorAll(selector.content));\n    }\n    // Type of `list` is sets of selector trees.\n    // We just join all the results.\n    // e.g. `p, span`\n    if (selector.type === 'list') {\n        const results = [];\n        for (const item of selector.list) {\n            for (const result of querySelectorAll(element, item)) {\n                if (!results.includes(result)) {\n                    results.push(result);\n                }\n            }\n        }\n        return results;\n    }\n    // Type of `compound` is a set of consecutive selectors.\n    // They're in chained form like `p:has(span)` and works as logical AND.\n    if (selector.type === 'compound') {\n        const results = [];\n        const [first, ...rest] = selector.compound;\n        for (const subjective of querySelectorAll(element, first)) {\n            for (const result of traverse(subjective, rest)) {\n                if (!results.includes(result)) {\n                    results.push(result);\n                }\n            }\n        }\n        return results;\n    }\n    // Type of `complex` is used to express CSS combinators: ` `, `>`, `+`, `~`.\n    // The `branch` function describes the behavior per combinator.\n    if (selector.type === 'complex') {\n        return handleComplexSelector(element, selector);\n    }\n    if (selector.type === 'pseudo-class') {\n        const results = [];\n        // This code is intended to be matched with `document.documentElement.querySelectorAll`.\n        // Since `document` is at the higher position rather `document.documentElement`,\n        // it can't select `html` for an instance.\n        for (const subjective of element.querySelectorAll('*')) {\n            for (const result of traverse(subjective, [selector])) {\n                if (!results.includes(result)) {\n                    results.push(result);\n                }\n            }\n        }\n        return results;\n    }\n    return [];\n}\n//# sourceMappingURL=eval.js.map","/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { tokenize, RECURSIVE_PSEUDO_CLASSES } from './parse.js';\nexport const EXTENDED_PSEUDO_CLASSES = new Set([\n    // '-abp-contains',\n    // '-abp-has',\n    // '-abp-properties',\n    'has-text',\n    'matches-path',\n    'matches-attr',\n    'matches-css',\n    'matches-css-after',\n    'matches-css-before',\n    'upward',\n    'xpath',\n    // 'if',\n    // 'if-not',\n    // 'min-text-length',\n    // 'nth-ancestor',\n    // 'watch-attr',\n    // 'watch-attrs',\n]);\nexport const PSEUDO_CLASSES = new Set([\n    'active',\n    'any',\n    'any-link',\n    'blank',\n    'checked',\n    'default',\n    'defined',\n    'dir',\n    'disabled',\n    'empty',\n    'enabled',\n    'first',\n    'first-child',\n    'first-of-type',\n    'focus',\n    'focus-visible',\n    'focus-within',\n    'fullscreen',\n    'has',\n    'host',\n    'host-context',\n    'hover',\n    'in-range',\n    'indeterminate',\n    'invalid',\n    'is',\n    'lang',\n    'last-child',\n    'last-of-type',\n    'left',\n    'link',\n    'matches',\n    // NOTE: by default we consider `:not(...)` to be a normal CSS selector since,\n    // we are only interested in cases where the argument is an extended selector.\n    // If that is the case, it will still be detected as such.\n    'not',\n    'nth-child',\n    'nth-last-child',\n    'nth-last-of-type',\n    'nth-of-type',\n    'only-child',\n    'only-of-type',\n    'optional',\n    'out-of-range',\n    'placeholder-shown',\n    'read-only',\n    'read-write',\n    'required',\n    'right',\n    'root',\n    'scope',\n    'target',\n    'valid',\n    'visited',\n    'where',\n]);\n// NOTE: here we only need to list the pseudo-elements which can appear with a\n// single colon (e.g. :after or ::after are valid for backward compatibility\n// reasons). They can be misinterpreted as pseudo-classes by the tokenizer for\n// this reason.\nexport const PSEUDO_ELEMENTS = new Set(['after', 'before', 'first-letter', 'first-line']);\nexport var SelectorType;\n(function (SelectorType) {\n    SelectorType[SelectorType[\"Normal\"] = 0] = \"Normal\";\n    SelectorType[SelectorType[\"Extended\"] = 1] = \"Extended\";\n    SelectorType[SelectorType[\"Invalid\"] = 2] = \"Invalid\";\n})(SelectorType || (SelectorType = {}));\nexport function classifySelector(selector) {\n    // In most cases there is no pseudo-anything so we can quickly exit.\n    if (selector.indexOf(':') === -1) {\n        return SelectorType.Normal;\n    }\n    const tokens = tokenize(selector);\n    // Detect pseudo-classes\n    let foundSupportedExtendedSelector = false;\n    for (const token of tokens) {\n        if (token.type === 'pseudo-class') {\n            const { name } = token;\n            if (EXTENDED_PSEUDO_CLASSES.has(name) === true) {\n                foundSupportedExtendedSelector = true;\n            }\n            else if (PSEUDO_CLASSES.has(name) === false && PSEUDO_ELEMENTS.has(name) === false) {\n                return SelectorType.Invalid;\n            }\n            // Check for nested :has selectors (which are not supported by standard CSS)\n            if (name === 'has' &&\n                token.argument !== undefined &&\n                token.argument.indexOf(':has(') !== -1) {\n                foundSupportedExtendedSelector = true;\n            }\n            // Recursively\n            if (foundSupportedExtendedSelector === false &&\n                token.argument !== undefined &&\n                RECURSIVE_PSEUDO_CLASSES.has(name) === true) {\n                const argumentType = classifySelector(token.argument);\n                if (argumentType === SelectorType.Invalid) {\n                    return argumentType;\n                }\n                else if (argumentType === SelectorType.Extended) {\n                    foundSupportedExtendedSelector = true;\n                }\n            }\n        }\n    }\n    if (foundSupportedExtendedSelector === true) {\n        return SelectorType.Extended;\n    }\n    return SelectorType.Normal;\n}\n//# sourceMappingURL=extended.js.map"],"names":["isAtoms","tokens","every","token","isAST","type","RECURSIVE_PSEUDO_CLASSES","Set","TOKENS","attribute","id","class","comma","combinator","TOKENS_WITH_PARENS","TOKENS_WITH_STRINGS","TRIM_TOKENS","TOKENS_FOR_RESTORE","Object","assign","splitOnMatch","pattern","str","lastIndex","match","exec","from","index","content","before","slice","after","length","groups","RegExp","source","replace","GRAMMAR","undefined","name","operator","value","namespace","caseSensitive","pos","argument","subtree","restoreNested","strings","regex","types","has","start","isEscaped","backslashes","gobbleQuotes","text","quote","end","indexOf","gobbleParens","stack","i","char","selector","replacement","opening","gobble","offset","push","repeat","tokenize","trim","doubleQuotes","selectorWithoutDoubleQuotes","singleQuotes","selectorWithoutQuotes","parens","selectorWithoutParens","strarr","tokenizer","splice","filter","a","tokenizeBy","nestTokens","list","some","t","selectors","temp","Error","sub","left","right","compound","walk","node","callback","o","parent","n","matchCSSProperty","element","cssValue","pseudoElement","property","isRegex","firstColonIndex","startsWith","lastIndexOf","parseCSSValue","win","ownerDocument","defaultView","actualValue","getComputedStyle","parseRegex","test","lastSlashIndex","flags","stripsWrappingQuotes","endsWith","matches","_a","s","querySelectorAll","traverse","textContent","includes","matchPattern","minLength","Number","isNaN","window","fullUrl","location","pathname","search","indexOfEqual","namePattern","valuePattern","valueRegex","matchingAttrs","attributes","attr","getAttribute","transpose","parentElement","number","isInteger","xpathExpression","Node","XPathResult","result","evaluate","ORDERED_NODE_SNAPSHOT_TYPE","resultType","elements","snapshotLength","snapshotItem","nodeType","ELEMENT_NODE","e","handleXPathSelector","root","traversals","results","traversal","pop","candidates","map","Array","item","first","rest","subjective","leftElements","leftElement","child","add","children","sibling","nextElementSibling","handleComplexSelector","EXTENDED_PSEUDO_CLASSES","PSEUDO_CLASSES","PSEUDO_ELEMENTS","SelectorType","classifySelector","Normal","foundSupportedExtendedSelector","Invalid","argumentType","Extended","parse","recursive","ast"],"mappings":"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"}