{"version":3,"file":"url-parser.umd.min.js","sources":["esm/const.js","esm/url-search-params.js","esm/immutable-url.js","esm/search-params-wrapper.js","esm/url.js","esm/utils.js"],"sourcesContent":["export const CODE_SPACE = 32;\nexport const CODE_HASH = 35;\nexport const CODE_PERCENT = 37;\nexport const CODE_AMPERSAND = 38;\nexport const CODE_PLUS = 43;\nexport const CODE_FORWARD_SLASH = 47;\nexport const CODE_COLON = 58;\nexport const CODE_SEMICOLON = 59;\nexport const CODE_EQUALS = 61;\nexport const CODE_QUESTION_MARK = 63;\nexport const CODE_AT = 64;\nexport const CODE_SQUARE_BRACKET_OPEN = 91;\nexport const CODE_SQUARE_BRACKET_CLOSE = 93;\n//# sourceMappingURL=const.js.map","import { CODE_AMPERSAND, CODE_EQUALS, CODE_SPACE } from './const.js';\nexport default class SearchParams {\n    get [Symbol.toStringTag]() {\n        return 'URLSearchParams';\n    }\n    constructor(init) {\n        this.isEncoded = false;\n        this.params = [];\n        if (typeof init === 'string') {\n            extractParams(init, init[0] === '?' ? 1 : 0, init.length, this, [CODE_AMPERSAND], CODE_EQUALS, [], {\n                encode: true,\n            });\n        }\n        else if (Array.isArray(init)) {\n            init.forEach((kv) => {\n                this.append(kv[0], kv[1]);\n            });\n        }\n        else if (typeof init === 'object') {\n            Object.keys(init).forEach((key) => {\n                this.append(key, init[key]);\n            });\n        }\n    }\n    *entries() {\n        for (let i = 0; i < this.params.length; i += 1) {\n            yield [\n                optionalDecode(this.params[i][0]),\n                optionalDecode(this.params[i][1]),\n            ];\n        }\n    }\n    append(name, value) {\n        this.params.push([encodeParameter(name), encodeParameter(value)]);\n    }\n    delete(name) {\n        this.params = this.params.filter(([key]) => optionalDecode(key) !== name);\n    }\n    forEach(callback) {\n        this.params.forEach(([key, value]) => {\n            callback(optionalDecode(value), optionalDecode(key), this);\n        });\n    }\n    get(name) {\n        const entry = this.params.find(([k]) => optionalDecode(k) === name);\n        if (entry) {\n            return optionalDecode(entry[1]);\n        }\n        return null;\n    }\n    getAll(name) {\n        return this.params\n            .filter(([key]) => optionalDecode(key) === name)\n            .map((kv) => kv[1]);\n    }\n    has(name) {\n        return this.get(name) !== null;\n    }\n    *keys() {\n        for (let i = 0; i < this.params.length; i += 1) {\n            yield optionalDecode(this.params[i][0]);\n        }\n    }\n    /**\n     * The set() method of the URLSearchParams interface sets the value associated with a given\n     * search parameter to the given value. If there were several matching values, this method\n     * deletes the others. If the search parameter doesn't exist, this method creates it.\n     * @param name\n     * @param value\n     */\n    set(name, value) {\n        const firstIndex = this.params.findIndex(([k]) => optionalDecode(k) === name);\n        if (firstIndex === -1) {\n            this.append(name, value);\n            return;\n        }\n        this.delete(name);\n        this.params.splice(firstIndex, 0, [\n            encodeParameter(name),\n            encodeParameter(value),\n        ]);\n    }\n    sort() {\n        this.params = this.params.sort((a, b) => a[0].localeCompare(b[0]));\n    }\n    toString() {\n        return this.params.map(([k, v]) => `${k}=${v}`).join('&');\n    }\n    *values() {\n        for (let i = 0; i < this.params.length; i += 1) {\n            yield optionalDecode(this.params[i][1]);\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    get size() {\n        return this.params.length;\n    }\n}\nexport function extractParams(urlString, start, end, params, separators, equals, breakCodes, { encode } = { encode: false }) {\n    let index = start;\n    let keyStart = index;\n    let keyEnd = 0;\n    let valStart = 0;\n    const appendParams = encode\n        ? params.append.bind(params)\n        : (n, v) => params.params.push([n, v]);\n    for (; index <= end; index += 1) {\n        const code = urlString.charCodeAt(index);\n        if (code === equals && keyEnd === 0) {\n            keyEnd = index;\n            valStart = index + 1;\n        }\n        else if (separators.indexOf(code) !== -1) {\n            // don't add if key and value are empty\n            if (index > keyStart) {\n                // push directly to the params array to skip encoding step\n                appendParams(urlString.slice(keyStart, keyEnd || index), urlString.slice(valStart || index, index));\n            }\n            keyStart = index + 1;\n            keyEnd = 0;\n            valStart = 0;\n        }\n        else if (breakCodes.indexOf(code) !== -1) {\n            break;\n        }\n    }\n    // push last key-value\n    if (index !== keyStart) {\n        appendParams(urlString.slice(keyStart, keyEnd || index), urlString.slice(valStart || index, index));\n    }\n    return index;\n}\nfunction optionalDecode(s) {\n    if (s.indexOf('%') !== -1) {\n        try {\n            return decodeURIComponent(s.replace(/\\+/g, ' '));\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        }\n        catch (_e) {\n            return s;\n        }\n    }\n    else {\n        return s;\n    }\n}\nfunction encodeParameter(_s) {\n    const s = '' + _s;\n    let encoded = '';\n    for (let i = 0; i < s.length; i++) {\n        if (s.charCodeAt(i) === CODE_SPACE) {\n            encoded += '+';\n        }\n        else {\n            encoded += encodeURIComponent(s[i]);\n        }\n    }\n    return encoded;\n}\n//# sourceMappingURL=url-search-params.js.map","import { parse } from 'tldts-experimental';\nimport { CODE_AMPERSAND, CODE_AT, CODE_COLON, CODE_EQUALS, CODE_FORWARD_SLASH, CODE_HASH, CODE_QUESTION_MARK, CODE_SEMICOLON, CODE_SQUARE_BRACKET_CLOSE, CODE_SQUARE_BRACKET_OPEN, } from './const.js';\nimport URLSearchParams, { extractParams } from './url-search-params.js';\nconst BREAK_HOST_ON = [CODE_FORWARD_SLASH, CODE_HASH, CODE_QUESTION_MARK];\nfunction isValidProtocolChar(code) {\n    return ((code >= 65 && code <= 90) || // A-Z\n        (code >= 97 && code <= 122) || // a-z\n        (code >= 48 && code <= 57) || // 0-9\n        code === 45 || // -\n        code === 43); // +\n}\n/**\n * A Fast implementation of url parsing, mostly API-compatible with the standard URL class while\n * being on average 2-3 times faster. Evaluation of URL components is lazy, so this implementation\n * should be fast for all use-cases.\n *\n * Known differences to standard URL:\n *  * Parameters returned via `URL.searchParams.entries()` are decoded only with\n *    `decodeURIComponent`. This differs to standards parsing in some subtle ways.\n *  * You can iterate a URL parameters array directly via `URL.searchParams.params`. This is around\n *    20% faster than using an iterator.\n *  * Parameter strings are parsed, and accessible via `URL.parameters`.\n *  * Domain parsing with tldts is built in. The `URL.domainInfo` attribute returns output from tldts'\n *    `parseHost` method.\n *  * Hostname validation is not done on initial parse. The `isValidHost()` method is provided for\n *    this purpose.\n *  * Some extra helper methods.\n *\n * See also for common API: https://developer.mozilla.org/en-US/docs/Web/API/URL\n */\nexport default class {\n    constructor(url) {\n        this.parse(url);\n    }\n    get protocol() {\n        return this._protocol;\n    }\n    get username() {\n        return this._username;\n    }\n    get password() {\n        return this._password;\n    }\n    get hostname() {\n        return this._hostname;\n    }\n    get host() {\n        return this._host;\n    }\n    get port() {\n        return this._port;\n    }\n    get pathname() {\n        return this._pathname;\n    }\n    /**\n     * The query string component of the URL, including the preceding `?` character.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/search\n     */\n    get search() {\n        if (!this._search) {\n            this._extractParams();\n        }\n        return this._search;\n    }\n    /**\n     * Parsed query string parameters, as a `URLSearchParams` object.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams\n     */\n    get searchParams() {\n        if (!this.isQueryParsed) {\n            this._extractSearchParams();\n        }\n        return this._query;\n    }\n    /**\n     * Parsed parameter string from the url. These are `;` separated key/values appearing in the URL\n     * path, before the query string.\n     */\n    get parameters() {\n        if (!this.isQueryParsed) {\n            this._extractSearchParams();\n        }\n        return this._parameters;\n    }\n    /**\n     * Check if the URL has a parameter string\n     * @returns true iff `;` occurs in the URL path before a `?`.\n     */\n    hasParameterString() {\n        return this.parameterStartIndex > 0;\n    }\n    /**\n     * URL hash or fragment component.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/hash\n     */\n    get hash() {\n        if (!this._search && !this._hash) {\n            this._extractParams();\n        }\n        return this._hash;\n    }\n    get href() {\n        return this._href;\n    }\n    /**\n     * Returns the url (post parsing).\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toString\n     */\n    toString() {\n        return this.href;\n    }\n    /**\n     * JSONified URL (== toString)\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toJSON\n     */\n    toJSON() {\n        return this.href;\n    }\n    /**\n     * Get parsed domainInfo from the hostname.\n     * @returns parsed domain, from tldts `parse` method.\n     */\n    get domainInfo() {\n        if (!this._domainInfo) {\n            this._domainInfo = parse(this.hostname, {\n                extractHostname: false,\n            });\n        }\n        return this._domainInfo;\n    }\n    /**\n     * Returns true iff the hostname of this url is an IP address. False otherwise.\n     */\n    get hostIsIp() {\n        return this.domainInfo.isIp;\n    }\n    /**\n     * Returns the hostname of the URL after parsing by tldts. This includes some error correction.\n     */\n    get domain() {\n        return this.domainInfo.hostname || this.hostname;\n    }\n    /**\n     * Get eTLD+1 of the hostname.\n     */\n    get generalDomain() {\n        return this.domainInfo.domain || this.hostname;\n    }\n    /**\n     * Legacy attribute for `pathname`.\n     */\n    get path() {\n        return this.pathname || '/';\n    }\n    /**\n     * Scheme = protocol without a trailing ':'.\n     */\n    get scheme() {\n        return this.protocol.slice(0, -1);\n    }\n    /**\n     * Check if the hostname of the URL is valid, i.e.\n     *  * it is an IP address, or\n     *  * it is a valid hostname with a known public suffix.\n     * @returns true if host is valid, otherwise false.\n     */\n    isValidHost() {\n        // if tldts was able to parse it, it's valid\n        return this.hostIsIp || this.generalDomain !== null;\n    }\n    /**\n     * Non-standard params extractor.\n     *\n     * Returns search params from parameter string and query params with more aggessive extraction\n     * than the standard URL implementation. Extra extraction features are:\n     *  * `;` separated parameters - used by multi trackers\n     * @returns URLSearchParams\n     */\n    extractKeyValues() {\n        if (this.parsedParameters) {\n            return this.parsedParameters;\n        }\n        this.parsedParameters = new URLSearchParams();\n        if (this.queryStartIndex === 0 && this.parameterStartIndex === 0) {\n            return this.parsedParameters;\n        }\n        const start = this.parameterStartIndex || this.queryStartIndex;\n        const end = this.href.length - 1;\n        let index = start;\n        if (this.href.charCodeAt(index) === CODE_SEMICOLON) {\n            // parameter string starts here\n            index = this._extractParamTuples(index + 1, end, this.parsedParameters, [CODE_SEMICOLON], CODE_EQUALS, [CODE_QUESTION_MARK, CODE_HASH]);\n        }\n        if (this.href.charCodeAt(index) === CODE_QUESTION_MARK) {\n            // query string starts here\n            index = this._extractParamTuples(index + 1, end, this.parsedParameters, [CODE_AMPERSAND, CODE_SEMICOLON], // allow '&' or ';' as separators\n            CODE_EQUALS, [CODE_HASH]);\n        }\n        return this.parsedParameters;\n    }\n    _extractHostname(start, end) {\n        let portIndex = 0;\n        let stopped = false;\n        let i = start;\n        let ipv6 = false;\n        let hasUpper = false;\n        // this is a IPv6 address - ignore everything until the closing bracket\n        if (this._href.charCodeAt(i) === CODE_SQUARE_BRACKET_OPEN) {\n            ipv6 = true;\n            for (; i <= end; i += 1) {\n                const code = this._href.charCodeAt(i);\n                if (code === CODE_SQUARE_BRACKET_CLOSE) {\n                    // after closed brackets can only be ':' or '/'\n                    const nextCode = this._href.charCodeAt(i + 1);\n                    if (nextCode === CODE_COLON) {\n                        portIndex = i + 1;\n                        i += 1;\n                        stopped = true;\n                    }\n                    else if (nextCode === CODE_FORWARD_SLASH) {\n                        i += 1;\n                        stopped = true;\n                    }\n                    else if (i !== end) {\n                        throw new TypeError('expected `:` or `/` after IPv6 address');\n                    }\n                    break;\n                }\n            }\n        }\n        if (!ipv6) {\n            for (; i <= end; i += 1) {\n                const code = this._href.charCodeAt(i);\n                if (code === CODE_COLON) {\n                    portIndex = i;\n                    stopped = true;\n                    break;\n                }\n                else if (code === CODE_AT) {\n                    // username without password\n                    this._username = this._href.slice(start, i);\n                    this._password = '';\n                    return this._extractHostname(i + 1, end);\n                }\n                if (BREAK_HOST_ON.indexOf(code) !== -1) {\n                    stopped = true;\n                    break;\n                }\n                else if (code <= 0x20) {\n                    throw new TypeError(`Invalid character '${this.href[i]}' in hostname`);\n                }\n                else if (code >= 65 && code <= 90) {\n                    hasUpper = true;\n                }\n            }\n        }\n        const hostnameEnd = !stopped ? i + 1 : i;\n        if (hasUpper) {\n            this._href = `${this._href.slice(0, start)}${this._href\n                .slice(start, hostnameEnd)\n                .toLowerCase()}${this._href.slice(hostnameEnd)}`;\n        }\n        this._hostname = this._href.slice(start, hostnameEnd);\n        if (portIndex > 0) {\n            i += 1;\n            const portStart = i;\n            let nonNumeric = false;\n            for (; i <= end; i += 1) {\n                const code = this._href.charCodeAt(i);\n                if (BREAK_HOST_ON.indexOf(code) !== -1) {\n                    this._port = this._href.slice(portStart, i);\n                    break;\n                }\n                else if (code === CODE_AT) {\n                    // this was actually a username and password - extract user:pass, then\n                    // parse the rest as a plain hostname\n                    this._username = this._href.slice(start, portIndex || i);\n                    this._password = this._href.slice(portIndex + 1, i);\n                    return this._extractHostname(i + 1, end);\n                }\n                else if (code < 48 || code > 57) {\n                    // non numeric character in port\n                    nonNumeric = true;\n                }\n            }\n            if (!this._port) {\n                this._port = this.href.slice(portStart, i);\n            }\n            // validate port - cannot contain non-numeric characters\n            if (nonNumeric) {\n                throw new TypeError('Invalid URL: port contains non numeric character');\n            }\n            // cannot be greater than 65535\n            if (this._port.length >= 5 && +this._port > 65535) {\n                throw new TypeError('Invalid URL: invalid port number');\n            }\n        }\n        this._host = this._href.slice(start, !stopped ? i + 1 : i);\n        this.origin = `${this._protocol}//${this._host}`;\n        return !stopped ? i + 1 : i;\n    }\n    _extractParams() {\n        if (this.queryStartIndex > 0) {\n            let index = this.queryStartIndex;\n            const end = this.href.length - 1;\n            if (this.href.charCodeAt(index) === CODE_QUESTION_MARK) {\n                let broken = false;\n                for (; index <= end; index += 1) {\n                    if (this.href.charCodeAt(index) === CODE_HASH) {\n                        broken = true;\n                        break;\n                    }\n                }\n                this._search = this.href.slice(this.queryStartIndex, broken ? index : end + 1);\n                if (this._search.length === 1) {\n                    this._search = '';\n                }\n            }\n            if (this.href.charCodeAt(index) === CODE_HASH) {\n                this._hash = this.href.slice(index, end + 1);\n            }\n        }\n    }\n    _extractSearchParams() {\n        this.isQueryParsed = true;\n        if (this.queryStartIndex === 0 && this.parameterStartIndex === 0) {\n            return;\n        }\n        const start = this.parameterStartIndex || this.queryStartIndex;\n        const end = this.href.length - 1;\n        let index = start;\n        if (this.href.charCodeAt(index) === CODE_SEMICOLON) {\n            // parameter string starts here\n            index = this._extractParamTuples(index + 1, end, this._parameters, [CODE_SEMICOLON], CODE_EQUALS, [CODE_QUESTION_MARK, CODE_HASH]);\n        }\n        if (this.href.charCodeAt(index) === CODE_QUESTION_MARK) {\n            // query string starts here\n            const searchStart = index;\n            index = this._extractParamTuples(index + 1, end, this._query, [CODE_AMPERSAND], CODE_EQUALS, [CODE_HASH]);\n            this._search = this.href.slice(searchStart, index);\n            if (this._search.length === 1) {\n                this._search = '';\n            }\n        }\n        if (this.href.charCodeAt(index) === CODE_HASH) {\n            this._hash = this.href.slice(index, end + 1);\n        }\n    }\n    _extractParamTuples(start, end, params, separators, equals, breakCodes) {\n        return extractParams(this.href, start, end, params, separators, equals, breakCodes);\n    }\n    parse(url) {\n        if (typeof url !== 'string' || url.length === 0) {\n            throw new TypeError(`${url} is not a valid URL`);\n        }\n        this._protocol = '';\n        this._hostname = '';\n        this._host = '';\n        this._port = '';\n        this._pathname = '';\n        this._username = '';\n        this._password = '';\n        this._search = '';\n        this._hash = '';\n        this.parameterStartIndex = 0;\n        this.queryStartIndex = 0;\n        this.isQueryParsed = false;\n        this._parameters = new URLSearchParams();\n        this._query = new URLSearchParams();\n        this._domainInfo = null;\n        this.parsedParameters = null;\n        let index = 0;\n        // end is within bound of url\n        let end = url.length - 1;\n        // cut whitespace from the beginning and end of url\n        while (url.charCodeAt(index) <= 0x20) {\n            index += 1;\n        }\n        while (url.charCodeAt(end) <= 0x20) {\n            end -= 1;\n        }\n        this._href = url.slice(index, end + 1);\n        end = this._href.length - 1;\n        let hasUpper = false;\n        // Parse protocol\n        for (; index <= end; index += 1) {\n            const code = this._href.charCodeAt(index);\n            if (code === CODE_COLON) {\n                this._protocol = this._href.slice(0, index + 1);\n                if (hasUpper) {\n                    this._protocol = this._protocol.toLowerCase();\n                    this._href = `${this._protocol}${this._href.slice(index + 1)}`;\n                }\n                break;\n            }\n            else if (!isValidProtocolChar(code)) {\n                // non alphabet character in protocol - not a valid protocol\n                throw new TypeError('Invalid URL protocol');\n            }\n            else if (code >= 65 && code <= 90) {\n                hasUpper = true;\n            }\n        }\n        if (index >= end) {\n            throw new TypeError('No protocol');\n        }\n        // skip '/' after ':'\n        this.slashes = '';\n        for (index += 1; index < end; index += 1) {\n            if (this._href.charCodeAt(index) !== CODE_FORWARD_SLASH) {\n                break;\n            }\n            else {\n                this.slashes += '/';\n            }\n        }\n        if (this.slashes.length >= 2) {\n            // Two slashes: Authority is included\n            index = this._extractHostname(index, end);\n        }\n        else {\n            // No authority\n            this._host = '';\n            this._hostname = '';\n            this.origin = 'null';\n        }\n        if (index >= end) {\n            // add trailing slash if missing\n            if (this._href.charCodeAt(end) !== CODE_FORWARD_SLASH) {\n                this._href += '/';\n            }\n            this._pathname = '/';\n        }\n        else {\n            const pathStart = index;\n            for (; index <= end; index += 1) {\n                const code = this._href.charCodeAt(index);\n                if (code === CODE_SEMICOLON && !this.parameterStartIndex) {\n                    this.parameterStartIndex = index;\n                }\n                else if (code === CODE_QUESTION_MARK || code === CODE_HASH) {\n                    this.queryStartIndex = index;\n                    break;\n                }\n            }\n            this._pathname =\n                this.href.slice(pathStart, this.queryStartIndex !== 0 ? this.queryStartIndex : end + 1) || '/';\n        }\n    }\n}\n//# sourceMappingURL=immutable-url.js.map","import URLSearchParams from './url-search-params.js';\n/**\n * Wraps URLSearchParams and pushes changes in search string to a parent\n * URL instance.\n */\nexport default class URLSearchParamsWrapper extends URLSearchParams {\n    constructor(url, init) {\n        super();\n        this.url = url;\n        this.params = init.params;\n    }\n    append(name, value) {\n        super.append(name, value);\n        this.url.search = this.toString();\n    }\n    delete(name) {\n        super.delete(name);\n        this.url.search = this.toString();\n    }\n    set(name, value) {\n        super.set(name, value);\n        this.url.search = this.toString();\n    }\n    sort() {\n        super.sort();\n        this.url.search = this.toString();\n    }\n}\n//# sourceMappingURL=search-params-wrapper.js.map","import { CODE_FORWARD_SLASH, CODE_HASH, CODE_QUESTION_MARK } from './const.js';\nimport ImmutableURL from './immutable-url.js';\nimport URLSearchParamsWrapper from './search-params-wrapper.js';\nfunction mutate(url, changes) {\n    const self = {\n        hash: changes.hash !== undefined ? changes.hash : url.hash,\n        host: changes.host !== undefined ? changes.host : url.host,\n        hostname: changes.hostname !== undefined ? changes.hostname : url.hostname,\n        password: changes.password !== undefined ? changes.password : url.password,\n        pathname: changes.pathname !== undefined ? changes.pathname : url.pathname,\n        port: changes.port !== undefined ? changes.port : url.port,\n        protocol: changes.protocol !== undefined ? changes.protocol : url.protocol,\n        search: changes.search !== undefined ? changes.search : url.search,\n        username: changes.username !== undefined ? changes.username : url.username,\n    };\n    if (changes.hostname || changes.port) {\n        if (self.protocol === 'https:' && self.port === '443') {\n            self.port = '';\n        }\n        else if (self.protocol === 'http:' && self.port === '80') {\n            self.port = '';\n        }\n        self.host = `${self.hostname}${self.port ? ':' : ''}${self.port}`;\n    }\n    const user = self.username\n        ? self.password\n            ? `${self.username}:${self.password}@`\n            : `${self.username}@`\n        : self.password\n            ? `:${self.password}@`\n            : '';\n    return new ImmutableURL(`${self.protocol}${url.slashes}${user}${self.host}${self.pathname}${self.search}${self.hash}`);\n}\nexport default class {\n    get [Symbol.toStringTag]() {\n        return 'URL';\n    }\n    constructor(url) {\n        this.url = new ImmutableURL(url);\n    }\n    get protocol() {\n        return this.url.protocol;\n    }\n    set protocol(value) {\n        const previousProtocol = this.url.protocol;\n        const colon = value.endsWith(':') ? '' : ':';\n        const href = `${value}${colon}${this.href.slice(previousProtocol.length)}`;\n        this.url = new ImmutableURL(href);\n    }\n    get username() {\n        return this.url.username;\n    }\n    set username(value) {\n        this.url = mutate(this, {\n            username: value || '',\n        });\n    }\n    get password() {\n        return this.url.password;\n    }\n    set password(value) {\n        this.url = mutate(this, {\n            password: value || '',\n        });\n    }\n    get hostname() {\n        return this.url.hostname;\n    }\n    set hostname(value) {\n        this.url = mutate(this, {\n            hostname: value || '',\n        });\n    }\n    get host() {\n        return this.url.host;\n    }\n    set host(value) {\n        this.url = mutate(this, {\n            host: value,\n        });\n    }\n    get origin() {\n        return this.url.origin;\n    }\n    get port() {\n        return this.url.port;\n    }\n    set port(value) {\n        this.url = mutate(this, {\n            port: value || '',\n        });\n    }\n    get pathname() {\n        return this.url.pathname;\n    }\n    set pathname(value) {\n        const pathname = value.charCodeAt(0) === CODE_FORWARD_SLASH ? value : `/${value}`;\n        this.url = mutate(this, {\n            pathname,\n        });\n    }\n    /**\n     * The query string component of the URL, including the preceding `?` character.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/search\n     */\n    get search() {\n        return this.url.search;\n    }\n    set search(value) {\n        const newQuery = value.charCodeAt(0) === CODE_QUESTION_MARK ? value.slice(1) : value;\n        this.url = mutate(this, {\n            search: newQuery.length > 0 ? `?${newQuery}` : '',\n        });\n    }\n    /**\n     * Parsed query string parameters, as a `URLSearchParams` object.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams\n     */\n    get searchParams() {\n        return new URLSearchParamsWrapper(this, this.url.searchParams);\n    }\n    /**\n     * Parsed parameter string from the url. These are `;` separated key/values appearing in the URL\n     * path, before the query string.\n     */\n    get parameters() {\n        return this.url.parameters;\n    }\n    /**\n     * Check if the URL has a parameter string\n     * @returns true iff `;` occurs in the URL path before a `?`.\n     */\n    hasParameterString() {\n        return this.url.hasParameterString();\n    }\n    /**\n     * URL hash or fragment component.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/hash\n     */\n    get hash() {\n        return this.url.hash;\n    }\n    set hash(value) {\n        const newHash = value.charCodeAt(0) === CODE_HASH ? value.slice(1) : value;\n        this.url = mutate(this, {\n            hash: newHash.length > 0 ? `#${newHash}` : '',\n        });\n    }\n    get href() {\n        return this.url.href;\n    }\n    set href(value) {\n        this.url = new ImmutableURL(value);\n    }\n    /**\n     * Returns the url (post parsing).\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toString\n     */\n    toString() {\n        return this.href;\n    }\n    /**\n     * JSONified URL (== toString)\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toJSON\n     */\n    toJSON() {\n        return this.href;\n    }\n    /**\n     * Get parsed domainInfo from the hostname.\n     * @returns parsed domain, from tldts `parse` method.\n     */\n    get domainInfo() {\n        return this.url.domainInfo;\n    }\n    /**\n     * Returns true iff the hostname of this url is an IP address. False otherwise.\n     */\n    get hostIsIp() {\n        return this.url.hostIsIp;\n    }\n    /**\n     * Returns the hostname of the URL after parsing by tldts. This includes some error correction.\n     */\n    get domain() {\n        return this.url.domain;\n    }\n    /**\n     * Get eTLD+1 of the hostname.\n     */\n    get generalDomain() {\n        return this.url.generalDomain;\n    }\n    /**\n     * Legacy attribute for `pathname`.\n     */\n    get path() {\n        return this.url.path;\n    }\n    /**\n     * Scheme = protocol without a trailing ':'.\n     */\n    get scheme() {\n        return this.url.scheme;\n    }\n    get slashes() {\n        return this.url.slashes;\n    }\n    /**\n     * Check if the hostname of the URL is valid, i.e.\n     *  * it is an IP address, or\n     *  * it is a valid hostname with a known public suffix.\n     * @returns true if host is valid, otherwise false.\n     */\n    isValidHost() {\n        // if tldts was able to parse it, it's valid\n        return this.url.isValidHost();\n    }\n    /**\n     * Non-standard params extractor.\n     *\n     * Returns search params from parameter string and query params with more aggessive extraction\n     * than the standard URL implementation. Extra extraction features are:\n     *  * `;` separated parameters - used by multi trackers\n     * @returns URLSearchParams\n     */\n    extractKeyValues() {\n        return this.url.extractKeyValues();\n    }\n}\n//# sourceMappingURL=url.js.map","import MutableURL from './url.js';\n/**\n * Checks if this URL's hostname is non-ascii, and if so returns a new URL with the hostname\n * punycoded. Otherwise returns itself.\n */\nexport function getPunycodeEncoded(toASCII, url) {\n    const punycodedHost = toASCII(url.hostname);\n    if (punycodedHost !== url.hostname) {\n        return new MutableURL(`${url.protocol}${url.slashes}${punycodedHost}${url.pathname}${url.search}${url.hash}`);\n    }\n    return url;\n}\n//# sourceMappingURL=utils.js.map"],"names":["CODE_HASH","CODE_SEMICOLON","CODE_QUESTION_MARK","SearchParams","Symbol","toStringTag","constructor","init","this","isEncoded","params","extractParams","length","encode","Array","isArray","forEach","kv","append","Object","keys","key","entries","i","optionalDecode","name","value","push","encodeParameter","filter","callback","get","entry","find","k","getAll","map","has","set","firstIndex","findIndex","delete","splice","sort","a","b","localeCompare","toString","v","join","values","iterator","size","urlString","start","end","separators","equals","breakCodes","index","keyStart","keyEnd","valStart","appendParams","bind","n","code","charCodeAt","indexOf","slice","s","decodeURIComponent","replace","_e","_s","encoded","encodeURIComponent","BREAK_HOST_ON","isValidProtocolChar","ImmutableURL","url","parse","protocol","_protocol","username","_username","password","_password","hostname","_hostname","host","_host","port","_port","pathname","_pathname","search","_search","_extractParams","searchParams","isQueryParsed","_extractSearchParams","_query","parameters","_parameters","hasParameterString","parameterStartIndex","hash","_hash","href","_href","toJSON","domainInfo","_domainInfo","extractHostname","hostIsIp","isIp","domain","generalDomain","path","scheme","isValidHost","extractKeyValues","parsedParameters","URLSearchParams","queryStartIndex","_extractParamTuples","_extractHostname","portIndex","stopped","ipv6","hasUpper","nextCode","TypeError","hostnameEnd","toLowerCase","portStart","nonNumeric","origin","broken","searchStart","slashes","pathStart","URLSearchParamsWrapper","super","mutate","changes","self","undefined","user","MutableURL","previousProtocol","colon","endsWith","newQuery","newHash","toASCII","punycodedHost"],"mappings":"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"}